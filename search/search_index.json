{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Data Science Wissensdatenbank","text":"<ul> <li>TODO: Modulportr\u00e4t</li> <li>TODO: Bewertungskriterien </li> <li>TODO: Erkl\u00e4rung Wissensdatenbank</li> <li>TODO: Verlinkung der Aufgaben</li> </ul>"},{"location":"data-engineering/drop_duplicates/","title":"Entfernen von Duplikaten","text":"<p>In der Arbeit mit Sensordaten k\u00f6nnen durch fehlerhafte Erfassung oder doppelte \u00dcbertragung Duplikate entstehen. Die Methode <code>drop_duplicates</code> von pandas erm\u00f6glicht es, solche Duplikate effizient zu entfernen und so die Daten konsistenter zu gestalten.  </p> <p>Hauptparameter f\u00fcr Sensordaten: </p> <ul> <li>subset: Gibt die Spalten an, auf deren Basis Duplikate gepr\u00fcft werden sollen, z. B. Zeitstempel oder Sensormessungen.  </li> <li>keep: Bestimmt, welches Duplikat beibehalten wird (<code>'first'</code>, <code>'last'</code> oder <code>False</code> f\u00fcr keines).  </li> </ul>"},{"location":"data-engineering/drop_duplicates/#beispiel-1-duplikate-basierend-auf-zeitstempeln-entfernen","title":"Beispiel 1: Duplikate basierend auf Zeitstempeln entfernen","text":"<p>Doppelte Eintr\u00e4ge in Sensordaten k\u00f6nnen vorkommen, z. B. wenn ein Sensor denselben Wert mehrfach sendet.  </p> <pre><code>import pandas as pd\n\n# Beispiel-Sensordaten mit Duplikaten\ndata = {\n    'Zeitstempel': ['2025-02-01 12:00', '2025-02-01 12:10', '2025-02-01 12:10', '2025-02-01 12:20'],\n    'Temperatur': [22.5, 23.0, 23.0, 24.5]\n}\ndf = pd.DataFrame(data)\ndf['Zeitstempel'] = pd.to_datetime(df['Zeitstempel'])\n\nprint(\"Originale Sensordaten:\")\nprint(df)\n\n# Duplikate basierend auf dem Zeitstempel entfernen\ndf_cleaned = df.drop_duplicates(subset='Zeitstempel', keep='first')\n\nprint(\"\\nNach Entfernen der Duplikate basierend auf dem Zeitstempel:\")\nprint(df_cleaned)\n</code></pre> <p>Ausgabe: <pre><code>Originale Sensordaten:\n          Zeitstempel  Temperatur\n0 2025-02-01 12:00:00        22.5\n1 2025-02-01 12:10:00        23.0\n2 2025-02-01 12:10:00        23.0\n3 2025-02-01 12:20:00        24.5\n\nNach Entfernen der Duplikate basierend auf dem Zeitstempel:\n          Zeitstempel  Temperatur\n0 2025-02-01 12:00:00        22.5\n1 2025-02-01 12:10:00        23.0\n3 2025-02-01 12:20:00        24.5\n</code></pre></p>"},{"location":"data-engineering/drop_duplicates/#beispiel-2-duplikate-vollstandig-entfernen","title":"Beispiel 2: Duplikate vollst\u00e4ndig entfernen","text":"<p>Wenn Sensoren fehlerhafte oder doppelte Eintr\u00e4ge senden, k\u00f6nnen diese komplett entfernt werden, um eine genaue Analyse sicherzustellen.  </p> <pre><code># Alle doppelten Eintr\u00e4ge entfernen (keine Eintr\u00e4ge behalten)\ndf_cleaned = df.drop_duplicates(keep=False)\n\nprint(\"\\nNach vollst\u00e4ndigem Entfernen der Duplikate:\")\nprint(df_cleaned)\n</code></pre> <p>Ausgabe: <pre><code>Nach vollst\u00e4ndigem Entfernen der Duplikate:\n          Zeitstempel  Temperatur\n0 2025-02-01 12:00:00        22.5\n3 2025-02-01 12:20:00        24.5\n</code></pre></p>"},{"location":"data-engineering/fillna/","title":"Bef\u00fcllen von fehlenden Werten","text":"<p>In der Arbeit mit Sensordaten treten oft L\u00fccken in den Datens\u00e4tzen auf, da Sensoren gelegentlich keine Messwerte liefern k\u00f6nnen. Diese fehlenden Werte (<code>NaN</code>) m\u00fcssen h\u00e4ufig bereinigt werden, um eine korrekte Analyse und Modellierung zu erm\u00f6glichen. Die Methode <code>fillna</code> von pandas bietet eine effektive M\u00f6glichkeit, solche L\u00fccken zu schliessen, indem fehlende Werte durch feste Werte, statistische Kennzahlen (z. B. Mittelwert) oder eine F\u00fcllstrategie wie Vorw\u00e4rts- oder R\u00fcckw\u00e4rtsf\u00fcllung ersetzt werden.</p> <p>F\u00fcr Sensordaten ist diese Methode besonders n\u00fctzlich, um:</p> <ul> <li>Zeitreihen zu gl\u00e4tten und kontinuierliche Daten sicherzustellen.</li> <li>Fehlende Werte auf Basis historischer Daten sinnvoll zu ersetzen.</li> <li>Daten f\u00fcr maschinelles Lernen oder weitere Analysen vorzubereiten.</li> </ul> <p>Hauptparameter f\u00fcr Sensordaten:</p> <ul> <li>value: Feste Werte, z. B. <code>0</code>, falls ein Sensorfehler oder ein erwartetes physikalisches Verhalten dies nahelegt.</li> <li>method: Vorw\u00e4rtsf\u00fcllung (<code>method='ffill'</code>) oder R\u00fcckw\u00e4rtsf\u00fcllung (<code>method='bfill'</code>), um Messl\u00fccken basierend auf benachbarten Werten zu schliessen.</li> </ul>"},{"location":"data-engineering/fillna/#beispiel-1-vorwartsfullung-bei-kontinuierlichen-sensordaten","title":"Beispiel 1: Vorw\u00e4rtsf\u00fcllung bei kontinuierlichen Sensordaten","text":"<p>Ein Anwendungsfall, bei dem Vorw\u00e4rtsf\u00fcllung sinnvoll ist, ist die Messung von Temperatur- oder Feuchtigkeitswerten, bei denen der letzte gemessene Wert bis zur n\u00e4chsten Messung g\u00fcltig bleibt.</p> <pre><code>import pandas as pd\n\n# Beispiel f\u00fcr Sensordaten mit fehlenden Werten\ndata = {\n    'Temperatur': [22.5, 23.0, None, 24.5, 25.0],\n    'Feuchtigkeit': [55.0, None, 60.0, None, 65.0]\n}\ntimestamps = ['2025-02-01 12:00', '2025-02-01 12:10', '2025-02-01 12:20', '2025-02-01 12:30', '2025-02-01 12:40']\ndf = pd.DataFrame(data, index=pd.to_datetime(timestamps))\n\nprint(\"Originale Sensordaten:\")\nprint(df)\n\n# Fehlende Werte durch Vorw\u00e4rtsf\u00fcllung schliessen\ndf_filled = df.fillna(method='ffill')\n\nprint(\"\\nNach Vorw\u00e4rtsf\u00fcllung der fehlenden Werte:\")\nprint(df_filled)\n</code></pre> <p>Ausgabe: <pre><code>Originale Sensordaten:\n                     Temperatur  Feuchtigkeit\n2025-02-01 12:00:00        22.5          55.0\n2025-02-01 12:10:00        23.0           NaN\n2025-02-01 12:20:00         NaN          60.0\n2025-02-01 12:30:00        24.5           NaN\n2025-02-01 12:40:00        25.0          65.0\n\nNach Vorw\u00e4rtsf\u00fcllung der fehlenden Werte:\n                     Temperatur  Feuchtigkeit\n2025-02-01 12:00:00        22.5          55.0\n2025-02-01 12:10:00        23.0          55.0\n2025-02-01 12:20:00        23.0          60.0\n2025-02-01 12:30:00        24.5          60.0\n2025-02-01 12:40:00        25.0          65.0\n</code></pre></p>"},{"location":"data-engineering/fillna/#beispiel-2-fullen-mit-0-bei-solarpanel-daten","title":"Beispiel 2: F\u00fcllen mit <code>0</code> bei Solarpanel-Daten","text":"<p>In manchen F\u00e4llen ist es sinnvoll, fehlende Werte mit <code>0</code> zu ersetzen, da sie ein erwartetes physikalisches Verhalten widerspiegeln. Zum Beispiel produziert ein Solarpanel in der Nacht keinen Strom, weshalb <code>NaN</code>-Werte durch <code>0</code> ersetzt werden k\u00f6nnen.</p> <pre><code>import pandas as pd\n\n# Beispiel f\u00fcr Sensordaten zur Stromproduktion von Solarpanels\ndata = {\n    'Solarstrom (kW)': [None, 0.0, 5.0, 10.0, None, None, 0.0, None]\n}\ntimestamps = [\n    '2025-02-01 00:00', '2025-02-01 06:00', '2025-02-01 10:00', \n    '2025-02-01 12:00', '2025-02-01 16:00', '2025-02-01 18:00', \n    '2025-02-01 20:00', '2025-02-01 23:59'\n]\ndf = pd.DataFrame(data, index=pd.to_datetime(timestamps))\n\nprint(\"Originale Sensordaten:\")\nprint(df)\n\n# Fehlende Werte durch 0 ersetzen, da nachts keine Stromproduktion stattfindet\ndf_filled = df.fillna(value=0)\n\nprint(\"\\nNach F\u00fcllen der fehlenden Werte mit 0:\")\nprint(df_filled)\n</code></pre> <p>Ausgabe: <pre><code>Originale Sensordaten:\n                     Solarstrom (kW)\n2025-02-01 00:00:00              NaN\n2025-02-01 06:00:00              0.0\n2025-02-01 10:00:00              5.0\n2025-02-01 12:00:00             10.0\n2025-02-01 16:00:00              NaN\n2025-02-01 18:00:00              NaN\n2025-02-01 20:00:00              0.0\n2025-02-01 23:59:00              NaN\n\nNach F\u00fcllen der fehlenden Werte mit 0:\n                     Solarstrom (kW)\n2025-02-01 00:00:00              0.0\n2025-02-01 06:00:00              0.0\n2025-02-01 10:00:00              5.0\n2025-02-01 12:00:00             10.0\n2025-02-01 16:00:00              0.0\n2025-02-01 18:00:00              0.0\n2025-02-01 20:00:00              0.0\n2025-02-01 23:59:00              0.0\n</code></pre></p> <p>In diesem Beispiel wurden <code>NaN</code>-Werte durch <code>0</code> ersetzt, da nachts keine Stromproduktion stattfindet. Diese Vorgehensweise hilft, die Daten logisch korrekt und f\u00fcr Analysen konsistent zu halten.</p>"},{"location":"data-engineering/outliers/","title":"Entfernen von Ausreissern mit dem z-Score","text":"<p>In Sensordaten k\u00f6nnen Ausreisser auftreten, zum Beispiel durch fehlerhafte Messungen oder ungew\u00f6hnliche Ereignisse. Ein h\u00e4ufiger Ansatz, um solche Werte zu erkennen und zu entfernen, ist die Berechnung des z-Scores.  </p>"},{"location":"data-engineering/outliers/#was-ist-der-z-score","title":"Was ist der z-Score?","text":"<p>Der z-Score ist ein Wert, der Ihnen hilft zu verstehen, wie weit ein bestimmter Wert vom Durchschnitt der anderen Werte entfernt ist. Um dies zu berechnen, verwenden wir die Standardabweichung, ein Mass daf\u00fcr, wie stark die Werte normalerweise vom Durchschnitt abweichen.</p> <p>Die Formel f\u00fcr den z-Score lautet:</p> \\[ z = \\frac{X - \\mu}{\\sigma} \\] <p>Dabei ist:</p> <ul> <li>\\(X\\): Der Wert, den Sie untersuchen m\u00f6chten (z. B. eine gemessene Temperatur).</li> <li>\\(\\mu\\): Der Durchschnitt der Werte (also der Mittelwert, den Sie aus allen Messungen berechnen).</li> <li>\\(\\sigma\\): Die Standardabweichung, die angibt, wie stark sich die Werte vom Durchschnitt unterscheiden. Eine hohe Standardabweichung bedeutet, dass die Werte weit verstreut sind, eine niedrige bedeutet, dass sie dicht beieinander liegen.</li> </ul>"},{"location":"data-engineering/outliers/#was-ist-die-standardabweichung","title":"Was ist die Standardabweichung?","text":"<p>Die Standardabweichung ist ein Mass daf\u00fcr, wie weit die einzelnen Werte im Durchschnitt vom Mittelwert entfernt sind. Wenn alle Werte in etwa gleich dem Durchschnitt sind, ist die Standardabweichung klein. Wenn die Werte stark variieren, ist die Standardabweichung gross.</p>"},{"location":"data-engineering/outliers/#was-bedeutet-der-z-score","title":"Was bedeutet der z-Score?","text":"<p>Der z-Score zeigt Ihnen, wie weit ein Wert vom Durchschnitt entfernt ist, und gibt dabei auch eine Vorstellung davon, wie normal oder ungew\u00f6hnlich dieser Wert im Vergleich zu den anderen ist. Hier einige Beispiele:</p> <ul> <li>z-Score = 0: Der Wert liegt genau im Durchschnitt. Das bedeutet, dass der Wert keinen Abstand zum Mittelwert hat.</li> <li>z-Score = +1: Der Wert liegt 1 Standardabweichung \u00fcber dem Durchschnitt. Etwa 68% der Werte in einer normal verteilten Menge liegen innerhalb von 1 Standardabweichung vom Durchschnitt.</li> <li>z-Score = -2: Der Wert liegt 2 Standardabweichungen unter dem Durchschnitt. Ungef\u00e4hr 95% der Werte liegen innerhalb von 2 Standardabweichungen vom Durchschnitt.</li> <li>z-Score = +3: Der Wert liegt 3 Standardabweichungen \u00fcber dem Durchschnitt. Nur etwa 99.7% der Werte einer normalen Verteilung liegen innerhalb von 3 Standardabweichungen vom Durchschnitt.</li> </ul>"},{"location":"data-engineering/outliers/#warum-ist-der-z-score-nutzlich","title":"Warum ist der z-Score n\u00fctzlich?","text":"<p>Der z-Score hilft Ihnen zu erkennen, ob ein Wert normal oder ungew\u00f6hnlich ist. Ein hoher z-Score (z. B. &gt; 3) oder ein sehr niedriger z-Score (z. B. &lt; -3) deutet darauf hin, dass der Wert weit vom Durchschnitt entfernt liegt und daher als Ausreisser betrachtet werden k\u00f6nnte. Solche Werte kommen in einer normalen Verteilung nur selten vor.</p>"},{"location":"data-engineering/outliers/#ein-einfaches-beispiel","title":"Ein einfaches Beispiel:","text":"<p>Stellen Sie sich vor, Sie messen die Temperatur an verschiedenen Tagen und bekommen Werte wie: - 20\u00b0C, 22\u00b0C, 21\u00b0C, 100\u00b0C, 23\u00b0C</p> <p>Der Durchschnitt dieser Temperaturen liegt etwa bei 22\u00b0C. Wenn wir die Standardabweichung berechnen und den z-Score f\u00fcr die Temperatur von 100\u00b0C berechnen, werden wir feststellen, dass dieser Wert weit vom Durchschnitt entfernt ist. Der z-Score f\u00fcr 100\u00b0C wird sehr hoch sein, was darauf hinweist, dass dieser Wert ein Ausreisser ist. In einer normalen Verteilung w\u00fcrden Werte wie 100\u00b0C nur in weniger als 0,3% der F\u00e4lle vorkommen (mehr als 3 Standardabweichungen vom Durchschnitt entfernt).</p>"},{"location":"data-engineering/outliers/#hinweis-zu-sensordaten","title":"Hinweis zu Sensordaten:","text":"<p>Das Entfernen von Ausreissern kann die Datenqualit\u00e4t verbessern, indem Extremwerte, die m\u00f6glicherweise Fehler sind, beseitigt werden. Allerdings besteht die Gefahr, dass auch g\u00fcltige, aber seltene Ereignisse entfernt werden, was zu einem Informationsverlust f\u00fchren k\u00f6nnte.  </p>"},{"location":"data-engineering/outliers/#beispiel-entfernen-von-ausreissern-aus-temperaturdaten","title":"Beispiel: Entfernen von Ausreissern aus Temperaturdaten","text":"<pre><code>import pandas as pd\n\n# Beispiel-Sensordaten mit Ausreissern (noch mehr Werte)\ndata = {\n    'Zeitstempel': ['2025-02-01 12:00', '2025-02-01 12:10', '2025-02-01 12:20', \n                    '2025-02-01 12:30', '2025-02-01 12:40', '2025-02-01 12:50', \n                    '2025-02-01 13:00', '2025-02-01 13:10', '2025-02-01 13:20', \n                    '2025-02-01 13:30', '2025-02-01 13:40', '2025-02-01 13:50', \n                    '2025-02-01 14:00', '2025-02-01 14:10', '2025-02-01 14:20'],\n    'Temperatur': [22.5, 23.0, 100.0, 24.5, 25.0, 23.5, 24.0, 22.0, 24.5, 23.0, \n                   23.8, 24.2, 22.5, 23.1, 24.3]  # 100.0 bleibt der Ausreisser\n}\ndf = pd.DataFrame(data)\ndf['Zeitstempel'] = pd.to_datetime(df['Zeitstempel'])\n\nprint(\"Originale Sensordaten:\")\nprint(df)\n\n# Berechnung des Mittelwerts und der Standardabweichung\nmean_temp = df['Temperatur'].mean()\nstd_temp = df['Temperatur'].std()\n\n# Berechnung des z-Scores\ndf['z_score'] = (df['Temperatur'] - mean_temp) / std_temp\n\n# Entfernen von Werten mit z-Score gr\u00f6sser als 3 oder kleiner als -3\ndf_cleaned = df[df['z_score'].abs() &lt;= 3]\n\n# Entfernen der Spalte 'z_score'\ndf_cleaned = df_cleaned.drop(columns=['z_score'])\n\nprint(\"\\nNach Entfernen der Ausreisser:\")\nprint(df_cleaned)\n</code></pre> <p>Ausgabe: <pre><code>Originale Sensordaten:\n           Zeitstempel  Temperatur\n0  2025-02-01 12:00:00        22.5\n1  2025-02-01 12:10:00        23.0\n2  2025-02-01 12:20:00       100.0\n3  2025-02-01 12:30:00        24.5\n                               ...\n\nNach Entfernen der Ausreisser basierend auf dem z-Score:\n           Zeitstempel  Temperatur\n0  2025-02-01 12:00:00        22.5\n1  2025-02-01 12:10:00        23.0\n3  2025-02-01 12:30:00        24.5\n4  2025-02-01 12:40:00        25.0\n                               ...\n</code></pre></p>"},{"location":"data-engineering/outliers/#erklarung-zur-folge-des-entfernens-von-ausreissern","title":"Erkl\u00e4rung zur Folge des Entfernens von Ausreissern","text":"<p>Durch das Entfernen von Ausreissern k\u00f6nnen Sensordaten konsistenter und f\u00fcr maschinelles Lernen oder Zeitreihenanalysen besser nutzbar gemacht werden. Allerdings k\u00f6nnten echte, aber seltene Ereignisse (z. B. ein extremer Temperaturanstieg) ebenfalls entfernt werden. Daher sollte der Schwellenwert f\u00fcr den z-Score mit Bedacht gew\u00e4hlt und der Kontext der Daten ber\u00fccksichtigt werden.</p>"},{"location":"data-engineering/time_indexes/","title":"Arbeiten mit Time-Indexes in Pandas","text":"<p>In diesem Dokument gehen wir auf die Grundlagen der Arbeit mit Zeitstempeln und Zeitindizes in Pandas ein. Dabei behandeln wir wichtige Themen wie das Finden fehlender Daten, das Sortieren von Indizes, das Arbeiten mit Zeitstempeln (z. B. Umwandlung in <code>datetime</code>), Zeitzonen und die Zeitumstellung (Sommerzeit).</p>"},{"location":"data-engineering/time_indexes/#erstellen-eines-dataframes-mit-zeitstempeln-und-fehlenden-daten","title":"Erstellen eines DataFrames mit Zeitstempeln und fehlenden Daten","text":"<p>Zun\u00e4chst erstellen wir einen einfachen DataFrame mit Zeitstempeln, einer Temperatur-Spalte und fehlenden Werten (<code>NA</code>). Dabei sorgen wir daf\u00fcr, dass die Zeitstempel korrekt als <code>datetime</code> erkannt werden, was f\u00fcr sp\u00e4tere Zeitreihen-Operationen wichtig ist.</p> <pre><code>import pandas as pd\n\n# Erstellen des DataFrames mit Zeitstempeln und fehlenden Werten (NA)\ndata_unsorted = [22.5, 23.0, pd.NA, 24.0, 25.0]\ndates_unsorted = ['2025-02-03', '2025-02-01', '2025-02-02', '2025-02-05', '2025-02-04']\n\n# Erstellen des DataFrames ohne Index\ndf = pd.DataFrame(data_unsorted, columns=['Temperatur'])\n\n# Umwandlung der Datumsangaben in datetime und Setzen des Index\ndf['Datum'] = pd.to_datetime(dates_unsorted)\ndf = df.set_index('Datum')\n\n# Ausgabe des DataFrames\nprint(df)\n</code></pre> <p>Ausgabe: <pre><code>           Temperatur\nDatum\n2025-02-03       22.5\n2025-02-01       23.0\n2025-02-02       &lt;NA&gt;\n2025-02-05       24.0\n2025-02-04       25.0\n</code></pre></p>"},{"location":"data-engineering/time_indexes/#erklarung","title":"Erkl\u00e4rung:","text":"<ul> <li>Die Zeitstempel in der Liste <code>dates_unsorted</code> werden mit <code>pd.to_datetime()</code> in das <code>datetime</code>-Format konvertiert.</li> <li>Der DataFrame wird dann mit <code>set_index()</code> so ver\u00e4ndert, dass die <code>Datum</code>-Spalte als Index verwendet wird.</li> </ul>"},{"location":"data-engineering/time_indexes/#index-sortierung","title":"Index-Sortierung","text":"<p>Nach der Umwandlung der Zeitstempel in <code>datetime</code> m\u00f6chten wir den Index so sortieren, dass die Zeitstempel in der richtigen Reihenfolge sind. Daf\u00fcr verwenden wir <code>sort_index()</code>.</p> <pre><code># Sortieren des Indexes nach Datum\ndf = df.sort_index()\n\n# Ausgabe des sortierten DataFrames\nprint(df)\n</code></pre> <p>Ausgabe: <pre><code>           Temperatur\nDatum\n2025-02-01       23.0\n2025-02-02       &lt;NA&gt;\n2025-02-03       22.5\n2025-02-04       25.0\n2025-02-05       24.0\n</code></pre></p>"},{"location":"data-engineering/time_indexes/#fehlende-daten-finden","title":"Fehlende Daten finden","text":"<p>Fehlende Werte sind h\u00e4ufig in Zeitreihen und k\u00f6nnen durch verschiedene Faktoren wie Sensorfehler oder Datenl\u00fccken entstehen. In Pandas k\u00f6nnen Sie fehlende Werte leicht erkennen, indem Sie <code>isnull()</code> verwenden.</p>"},{"location":"data-engineering/time_indexes/#beispiel-fehlende-daten-finden","title":"Beispiel: Fehlende Daten finden","text":"<pre><code># Ausgabe der Zeilen mit fehlenden Daten\nprint(\"Zeilen mit fehlenden Daten:\")\nprint(df[df.isnull().values])\n</code></pre> <p>Ausgabe: <pre><code>Zeilen mit fehlenden Daten:\n           Temperatur\nDatum\n2025-02-02       &lt;NA&gt;\n</code></pre></p>"},{"location":"data-engineering/time_indexes/#zeitzonen-und-sommerzeit","title":"Zeitzonen und Sommerzeit","text":"<p>Es ist wichtig, sicherzustellen, dass Zeitstempel mit der richtigen Zeitzone und unter Ber\u00fccksichtigung der Sommerzeit (Daylight Saving Time) behandelt werden. Um dies zu erreichen, k\u00f6nnen Sie die <code>tz_localize()</code> und <code>tz_convert()</code> Funktionen in Pandas verwenden.</p>"},{"location":"data-engineering/time_indexes/#beispiel-umgang-mit-zeitzonen-und-sommerzeit","title":"Beispiel: Umgang mit Zeitzonen und Sommerzeit","text":"<p>In diesem Beispiel stellen wir sicher, dass die Zeitstempel korrekt lokalisiert und in eine andere Zeitzone konvertiert werden, dabei die Sommerzeit korrekt ber\u00fccksichtigt wird.</p> <pre><code># Lokalisieren des DatetimeIndex in der Zeitzone Z\u00fcrich\ndf.index = df.index.tz_localize('Europe/Zurich')\n\n# Umwandeln der Zeitzone in UTC\ndf.index = df.index.tz_convert('UTC')\n\n# Ausgabe des DataFrames mit Zeitzonenbehandlung\nprint(df)\n</code></pre> <p>Ausgabe: <pre><code>                          Temperatur\nDatum\n2025-01-31 23:00:00+00:00       23.0\n2025-02-01 23:00:00+00:00       &lt;NA&gt;\n2025-02-02 23:00:00+00:00       22.5\n2025-02-03 23:00:00+00:00       25.0\n2025-02-04 23:00:00+00:00       24.0\n</code></pre></p> <p>Erkl\u00e4rung: - Zun\u00e4chst haben wir den <code>datetime</code>-Index in die Zeitzone <code>Europe/Zurich</code> lokalisiert. - Anschliessend wurde der Index in die UTC-Zeitzone konvertiert.</p>"},{"location":"data-engineering/time_indexes/#resampling-einer-zeitreihe","title":"Resampling einer Zeitreihe","text":"<p>Resampling ist eine Technik, um die Frequenz einer Zeitreihe zu \u00e4ndern. Wenn Sie zum Beispiel t\u00e4gliche Daten auf st\u00fcndliche Daten umstellen m\u00f6chten, k\u00f6nnen Sie Resampling verwenden. Dabei ist es wichtig, zu verstehen, wie mit fehlenden Zeitstempeln umgegangen wird.</p>"},{"location":"data-engineering/time_indexes/#erklarung-zu-resample","title":"Erkl\u00e4rung zu <code>resample()</code>","text":"<p>Die Methode <code>resample()</code> wird verwendet, um die Frequenz einer Zeitreihe zu \u00e4ndern und dabei Daten zu aggregieren. Zum Beispiel k\u00f6nnen Sie t\u00e4gliche Daten auf monatliche Daten umstellen oder st\u00fcndliche Daten auf t\u00e4gliche Daten reduzieren. Die Methode erlaubt es Ihnen, eine Frequenz f\u00fcr die Zeitreihe zu definieren und dann eine Aggregationsmethode anzuwenden (z.B. Mittelwert, Summe, etc.).</p> <p>Parameter von <code>resample()</code>:</p> <ul> <li> <p>Frequenz: Die neue Frequenz, die Sie f\u00fcr die Zeitreihe angeben m\u00f6chten. Die Frequenz wird durch einen String bestimmt, wie z.B.:</p> </li> <li> <p><code>'h'</code> \u2013 st\u00fcndlich</p> </li> <li><code>'min'</code> \u2013 min\u00fctlich</li> <li><code>'s'</code> \u2013 sekundlich</li> <li><code>'D'</code> \u2013 t\u00e4glich</li> <li><code>'B'</code> \u2013 Werktage</li> <li><code>'W'</code> \u2013 w\u00f6chentlich</li> <li><code>'ME'</code> \u2013 monatlich</li> <li><code>'QE'</code> \u2013 viertelj\u00e4hrlich</li> <li><code>'YE'</code> \u2013 j\u00e4hrlich</li> <li>Zusammengesetzte Frequenzen sind ebenfalls m\u00f6glich, z.B. <code>'2W'</code> f\u00fcr alle zwei Wochen.</li> </ul> <p>Methode zur Aggregation: Nachdem die Frequenz ge\u00e4ndert wurde, k\u00f6nnen Sie eine Aggregationsmethode auf den resampleten Datensatz anwenden, z.B. <code>mean()</code>, <code>sum()</code>, <code>max()</code>, usw.</p> <p>Beispiel: Resampling auf st\u00fcndliche Frequenz mit Mittelwert</p> <pre><code># Resampling auf st\u00fcndliche Frequenz und Berechnung des Mittelwerts\ndf_resampled = df.resample('h').mean()\n</code></pre>"},{"location":"data-engineering/time_indexes/#erklarung-zu-asfreq","title":"Erkl\u00e4rung zu <code>asfreq()</code>","text":"<p>Die Methode <code>asfreq()</code> wird verwendet, um die Frequenz einer Zeitreihe zu \u00e4ndern, ohne dabei die Daten zu aggregieren. Sie f\u00fcgt einfach fehlende Zeitstempel basierend auf der angegebenen Frequenz hinzu und f\u00fcllt die Werte mit <code>NaN</code>, falls f\u00fcr diese Zeitstempel keine Daten vorhanden sind. Es erfolgt keine Aggregation der Daten, sondern lediglich eine Umstellung der Zeitreihenfrequenz.</p> <p>Beispiel: Resampling auf st\u00fcndliche Frequenz ohne Aggregation</p> <pre><code># Resampling auf st\u00fcndliche Frequenz ohne Auff\u00fcllen der fehlenden Werte\ndf_resampled = df.resample('h').asfreq()\n\n# Ausgabe des resampleten DataFrames ohne Auff\u00fcllen\nprint(df_resampled)\n</code></pre> <p>Ausgabe: <pre><code>                          Temperatur\nDatum\n2025-01-31 23:00:00+00:00       23.0\n2025-02-01 00:00:00+00:00        NaN\n2025-02-01 01:00:00+00:00        NaN\n2025-02-01 02:00:00+00:00        NaN\n2025-02-01 03:00:00+00:00        NaN\n...                              ...\n2025-02-04 19:00:00+00:00        NaN\n2025-02-04 20:00:00+00:00        NaN\n2025-02-04 21:00:00+00:00        NaN\n2025-02-04 22:00:00+00:00        NaN\n2025-02-04 23:00:00+00:00       24.0\n</code></pre></p>"}]}